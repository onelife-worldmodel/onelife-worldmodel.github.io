<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>One Life to Learn: Inferring Symbolic World Models for Stochastic Environments from Unguided Exploration</title>
    
    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="One Life to Learn: Inferring Symbolic World Models for Stochastic Environments from Unguided Exploration">
    <meta property="og:description" content="OneLife synthesizes symbolic world models from a single unguided episode in hostile, stochastic environments. A framework that models world dynamics through conditionally activated programmatic laws within a probabilistic programming framework.">
    <meta property="og:image" content="https://onelife-worldmodel.github.io/static/website-teaser.gif">
    <meta property="og:url" content="https://onelife-worldmodel.github.io">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&family=DM+Serif+Display:ital@0;1&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåç</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'DM Sans', sans-serif;
            line-height: 1.6;
        }
        .publication-title {
            font-family: 'DM Serif Display', serif;
            font-weight: 400;
            font-size: 2.3rem !important;
            line-height: 1.2;
            margin-bottom: 1.5rem;
        }
        .author-block {
            font-family: 'DM Sans', sans-serif;
            font-weight: 400;
        }
        .content-block {
            max-width: 800px;
        }
        .abstract {
            font-family: 'DM Sans', sans-serif;
            font-weight: 400;
            font-size: 1.1rem;
            line-height: 1.8;
        }
        .teaser .hero-body {
            padding-top: 3rem;
            padding-bottom: 3rem;
        }
        .teaser {
            font-family: 'DM Sans', sans-serif;
        }
        .teaser img {
            max-height: 500px;
            width: auto;
            margin: 0 auto 2rem;
            display: block;
        }
        .publication-links {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .link-block {
            flex: 0 0 auto;
        }
        .content {
            font-family: 'DM Sans', sans-serif;
        }
        .navbar, .footer {
            font-family: 'DM Sans', sans-serif;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'DM Serif Display', serif;
            font-weight: 400;
        }
        .example-images {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .example-column {
            width: 24%;
            margin-bottom: 1rem;
        }
        .example-column img {
            width: 100%;
            height: auto;
            object-fit: cover;
        }
        
        @media screen and (max-width: 768px) {
            .example-column {
                width: 48%;
            }
        }
        
        @media screen and (max-width: 480px) {
            .example-column {
                width: 100%;
            }
        }
        .limited-width-image {
            max-width: 400px;
            margin: 0 auto;
            display: block;
        }
        .tabs.is-boxed a {
            padding: 0.75rem 1.5rem;
        }
        .tabs .icon {
            margin-right: 0.5rem;
        }
        .tab-text {
            font-size: 1.1rem;
            font-weight: 600;
        }
        @media screen and (max-width: 768px) {
            .publication-links {
                flex-direction: column;
                align-items: center;
            }
            .link-block {
                width: 100%;
                max-width: 200px;
            }
            .link-block .button {
                width: 100%;
            }
        }
        
        .dataTables_wrapper {
            overflow-x: auto;
        }
        
        table.dataTable {
            width: 100% !important;
        }
        
        .dataTables_scrollBody {
            overflow-x: hidden !important;
            width: 100% !important;
        }

        @media screen and (max-width: 768px) {
            .tabs ul {
                flex-wrap: wrap;
            }
            .tabs li {
                flex-basis: 100%;
            }
            .tabs.is-boxed a {
                border-radius: 0;
                margin-bottom: 1px;
            }
        }

        .table-container {
            overflow-x: auto;
        }

        .table {
            width: 100%;
            min-width: 600px;
            table-layout: fixed;
        }

        .table th,
        .table td {
            padding: 0.5rem;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .table th:nth-child(1),
        .table td:nth-child(1) {
            width: 25%;
        }
        .table th:nth-child(2),
        .table td:nth-child(2) {
            width: 20%;
        }
        .table th:nth-child(3),
        .table td:nth-child(3) {
            width: 25%;
        }
        .table th:nth-child(4),
        .table td:nth-child(4) {
            width: 20%;
        }
        .table th:nth-child(5),
        .table td:nth-child(5) {
            width: 10%;
        }

        @media screen and (max-width: 768px) {
            .table th,
            .table td {
                font-size: 0.9rem;
                padding: 0.4rem;
            }
        }

        @media screen and (max-width: 480px) {
            .table th,
            .table td {
                font-size: 0.8rem;
                padding: 0.3rem;
            }
        }

        .publication-links .button {
            background: linear-gradient(to right, #292524, #44403c);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: 2.8em;
            padding: 0 1.5em;
            border-radius: 8px !important;
        }

        @media screen and (max-width: 768px) {
            .publication-links .button {
                border-radius: 6px !important;
            }
        }

        .publication-links .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: linear-gradient(to right, #44403c, #292524);
        }

        h2.title {
            font-family: 'DM Serif Display', serif;
            font-weight: 400;
            line-height: 1.3;
            margin-bottom: 1.2rem;
        }

        .content p {
            font-family: 'DM Sans', sans-serif;
            line-height: 1.7;
        }

        .section {
            padding: 3rem 1.5rem;
        }

        .system-name {
            font-family: 'JetBrains Mono', monospace;
            color: #2563eb;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .caption {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #4a4a4a;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        
        .caption a {
            color: #2563eb;
            text-decoration: none;
            border-bottom: 1px solid rgba(37, 99, 235, 0.3);
            transition: all 0.2s ease;
        }
        
        .caption a:hover {
            color: #1d4ed8;
            border-bottom-color: #1d4ed8;
        }
        
        .efa-term {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        /* Law Carousel Styles */
        .law-carousel-container {
            position: relative;
            max-width: 900px;
            margin: 2rem auto;
        }
        
        .law-carousel {
            background: #282c34;
            border-radius: 8px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }
        
        .law-slide {
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
        }
        
        .law-slide.active {
            display: block;
            opacity: 1;
        }
        
        .law-title {
            font-family: 'DM Serif Display', serif;
            font-size: 1.5rem;
            color: #61dafb;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .law-code-container {
            max-height: 500px;
            overflow: auto;
            border-radius: 4px;
        }
        
        .law-code-container pre {
            margin: 0;
            background: transparent;
        }
        
        .law-code-container code {
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .carousel-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.5rem;
        }
        
        .carousel-button {
            background: linear-gradient(to right, #292524, #44403c);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .carousel-button:hover {
            background: linear-gradient(to right, #44403c, #292524);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .carousel-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .carousel-indicators {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .carousel-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .carousel-dot.active {
            background: #61dafb;
            width: 12px;
            height: 12px;
        }
        
        .carousel-counter {
            font-family: 'DM Sans', sans-serif;
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
        }
        
        @media screen and (max-width: 768px) {
            .law-carousel {
                padding: 1rem;
            }
            
            .carousel-button {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
            
            .law-code-container code {
                font-size: 0.8rem;
            }
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox-plus-jquery.min.js"></script>
</head>
<body>

<nav class="navbar" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
        <a class="navbar-item" href="https://zaidkhan.me/">
            <span class="icon">
                <i class="fas fa-home"></i>
            </span>
        </a>
    </div>
</nav>

<section class="hero">
    <div class="hero-body">
        <div class="container is-max-desktop">
            <div class="columns is-centered">
                <div class="column has-text-centered">
                    <h1 class="title is-1 publication-title">One Life to Learn: Inferring Symbolic World Models for Stochastic Environments from Unguided Exploration</h1>
                    <div class="is-size-5 publication-authors">
                        <span class="author-block">
                            <a href="https://zaidkhan.me/">Zaid Khan</a>,
                        </span>
                        <span class="author-block">
                            <a href="https://archiki.github.io/">Archiki Prasad</a>,
                        </span>
                        <span class="author-block">
                            <a href="https://esteng.github.io/">Elias Stengel-Eskin</a>,
                        </span>
                        <span class="author-block">
                            <a href="https://j-min.io/">Jaemin Cho</a>,
                        </span>
                        <span class="author-block">
                            <a href="https://www.cs.unc.edu/~mbansal/">Mohit Bansal</a>
                        </span>
                    </div>

                    <div class="is-size-5 publication-authors">
                        <span class="author-block">University of North Carolina, Chapel Hill</span>
                        <br>
                    </div>

                    <div class="column has-text-centered">
                        <div class="publication-links">
                            <span class="link-block">
                                <a href="https://arxiv.org/abs/2510.12088" class="external-link button is-normal is-dark">
                                    <span class="icon">
                                        <i class="ai ai-arxiv"></i>
                                    </span>
                                    <span>Paper</span>
                                </a>
                            </span>
                            <span class="link-block">
                                <a href="https://github.com/codezakh/onelife" class="external-link button is-normal is-rounded is-dark">
                                    <span class="icon">
                                        <i class="fab fa-github"></i>
                                    </span>
                                    <span>OneLife</span>
                                </a>
                            </span>
                            <span class="link-block">
                                <a href="https://github.com/codezakh/crafter_oo" class="external-link button is-normal is-rounded is-dark">
                                    <span class="icon">
                                        <i class="fab fa-github"></i>
                                    </span>
                                    <span>Crafter-OO</span>
                                </a>
                            </span>
                            <span class="link-block">
                                <button class="button is-normal is-rounded is-dark" id="copy-citation">
                                    <span class="icon">
                                        <i class="fas fa-copy"></i>
                                    </span>
                                    <span>BibTeX</span>
                                </button>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="hero teaser" style="margin-top: -3rem;">
    <div class="container is-max-desktop">
        <div class="hero-body" style="padding-top: 0; padding-bottom: 0;">
            <img src="static/website-teaser.gif" alt="OneLife Overview" style="margin-bottom: 1rem;">
            <div class="caption">
                <span class="system-name">OneLife</span> synthesizes world laws from a single unguided (no environment-specific rewards / goals) episode in a hostile, stochastic environment
                <span class="system-name">OneLife</span> models the world as mixture of laws written in code with a precondition-effect structure, each governing an aspect of the world, and infers parameters for the mixture that best explain the observed dynamics of the world.
                The resulting world model (WM) provides a probability distribution over attributes of an object-oriented world state, such as the <code>position</code> of a particular zombie.
                <span class="system-name">OneLife</span> outperforms a strong baseline in modeling 16/23 core game mechanics tested, measured by MRR (Mean Reciprocal Rank) of the true next state (<a href="#sec-evaluation">see evaluation</a>) under the WM's likelihood.
                See <a href="zombie-law.html">zombie law</a> for a synthesized zombie law.
            </div>
        </div>
    </div>
</section>

<section class="section">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified abstract">
            <p>
                Symbolic world modeling is the task of inferring and representing the transitional
                dynamics of an environment as an executable program. Previous research on
                symbolic world modeling has focused on largely deterministic environments with
                abundant interaction data, simple mechanics, and human-provided guidance. We
                address the more realistic and challenging problem of learning a symbolic world
                model in a complex, stochastic environment with severe constraints: a limited
                interaction budget where the agent has only "one life" to explore a hostile environment and no external guidance in the form of human-provided, environment-specific rewards or goals. We introduce <span class="system-name">OneLife</span>, a framework that models world
                dynamics through conditionally activated programmatic laws within a probabilistic programming framework. Each law operates through a precondition-effect
                structure, allowing it to remain silent on irrelevant aspects of the world state and
                predict only the attributes it directly governs. This creates a dynamic computation graph that routes both inference and optimization only through relevant laws
                for each transition, avoiding the scaling challenges that arise when all laws must
                contribute to predictions about a complex, hierarchical state space, and enabling
                accurate learning of stochastic dynamics even when most rules are inactive at any
                given moment. To evaluate our approach under these demanding constraints, we
                introduce a new evaluation protocol that measures (a) state ranking, the ability to
                distinguish plausible future states from implausible ones, and (b) state fidelity,
                the ability to generate future states that closely resemble reality. We develop
                and evaluate our framework on Crafter-OO, our reimplementation of the popular Crafter environment that exposes a structured, object-oriented symbolic state
                and a pure transition function that operates on that state alone. <span class="system-name">OneLife</span> can successfully learn key environment dynamics from minimal, unguided interaction,
                outperforming a strong baseline on 16 out of 23 scenarios tested. We also demonstrate the world model's utility for planning, where rollouts simulated within the
                world model successfully identify superior strategies in goal-oriented tasks. Our
                work establishes a foundation for autonomously constructing programmatic world
                models of unknown, complex environments.

            </p>
        </div>
    </div>
</section>

<section class="section" id="sec-how-it-works">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">How <span class="system-name">OneLife</span> Works</h2>
        <div class="content has-text-justified">
            <figure style="margin-bottom: 1.5rem;">
                <img src="static/comp_graph.png" alt="Computation graph and dynamic routing of laws" style="width: 100%; max-width: 900px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Illustration of the inference process. The active laws for each observable (defined by \(\mathcal{I}_k(s_t, a)\)) determine the structure of the computation graph, i.e., which laws and their corresponding parameters \(\theta_i\) are related to which observables. This structure in turn informs the parameter updates. 
                    Shown here is a dataset with a single transition instance, in which the player (P) moves right; at the same time, a zombie (Z) independently moves left. 
                    This implicates two laws, <code>PlayerMovementLaw</code> and <code>ZombieMovementLaw</code>, while not implicating the <code>InventoryUpdateLaw</code>. 
                    As a result, the loss computation is only a function of \(\theta_1\) and \(\theta_2\). Note we use \(Z\) here to denote the normalizing factor.
                </figcaption>
            </figure>

            <p><strong>Mixture of programmatic laws (precondition‚Äìeffect) + observables:</strong> We represent dynamics as a mixture of modular laws written in code. Each law activates when its precondition holds and only predicts a subset of state <em>observables</em> (e.g., <code>player.position</code>), creating a sparse, modular interface that scales to complex, object-oriented states.</p>

            <p><strong>Unguided exploration with atomic law synthesis:</strong> A language-model‚Äìdriven exploration policy collects a single episode without rewards or goals. A general synthesizer then proposes simple, atomic laws that explain observed transitions (decomposing complex events into minimal attribute changes) to form a broad hypothesis set.</p>

            <p><strong>Dynamic routing inference + forward simulation:</strong> For each transition, gradients and credit are <em>dynamically routed</em> only through active laws for the relevant observables; we fit the law weights via a weighted product-of-experts objective (optimized with L-BFGS). The learned model supports likelihood scoring and generative rollouts by sampling per-observable predictions and reconstructing the next symbolic state.</p>
        </div>
    </div>
</section>

<section class="section" id="sec-crafter-oo">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Crafter-OO: A Testbed for Symbolic World Modeling</h2>
        <div class="content has-text-justified">
            <p>
                A common design assumption in previous work on symbolic world modeling is that we have access to an object-oriented world state to use as input to the symbolic world model under construction. In practice, this state is only easily accessible for simple environments such as Minigrid or BabyAI. Programmatic access to the state of more complex environments such as Atari games is only possible due to standalone development efforts such as OCAtari which makes the internal object-oriented state of these environments accessible to researchers. The lack of an environment with an exposed, object-oriented state that is more complex than gridworlds or with mechanics more diverse than Atari games has thus far prevented evaluation and development of symbolic world modeling approaches for more complex environments.
            </p>
            
            <p>
                To close this gap, we implement <strong>Crafter-OO</strong>, which emulates the Crafter environment by operating purely on an explicit, object-oriented game state. Additionally, we contribute utilities for programmatically modifying the game state to create evaluation scenarios.
            </p>

            <h3 class="title is-4">Interactive State Transition Example</h3>
            <p>
                Below is a simple example showing how actions transform the object-oriented game state in Crafter-OO. Click the button to see how the state changes when the player takes an action.
            </p>

            <div style="margin: 2rem 0;">
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; justify-content: center;">
                    <button class="button is-primary" id="action-btn-1" onclick="applyAction(1)">
                        <span class="icon"><i class="fas fa-hand-rock"></i></span>
                        <span>Action: Do (Collect Wood)</span>
                    </button>
                    <button class="button is-info" id="action-btn-2" onclick="applyAction(2)">
                        <span class="icon"><i class="fas fa-arrow-right"></i></span>
                        <span>Action: Move East</span>
                    </button>
                    <button class="button is-warning" id="reset-btn" onclick="resetState()">
                        <span class="icon"><i class="fas fa-undo"></i></span>
                        <span>Reset</span>
                    </button>
                </div>

                <div style="display: grid; grid-template-columns: 1fr; gap: 1rem;">
                    <div>
                        <h4 class="title is-6">Current State</h4>
                        <div style="position: relative;">
                            <pre class="json-state-container"><code id="current-state" class="language-json" style="display: block;"></code></pre>
                            <div class="scroll-indicator">
                                <i class="fas fa-chevron-down"></i> Scroll to see more
                            </div>
                            <div class="fade-overlay"></div>
                        </div>
                    </div>
                    
                    <div id="diff-container" style="display: none;">
                        <h4 class="title is-6">Changes (Diff)</h4>
                        <div style="position: relative;">
                            <pre id="state-diff" class="diff-container-pre"></pre>
                            <div class="scroll-indicator-diff">
                                <i class="fas fa-chevron-down"></i> Scroll to see more
                            </div>
                            <div class="fade-overlay-diff"></div>
                        </div>
                    </div>
                </div>
            </div>

            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>

            <style>
                .diff-add { background-color: #d4edda; color: #155724; }
                .diff-remove { background-color: #f8d7da; color: #721c24; }
                .diff-context { color: #6c757d; }
                
                /* Container for JSON state with visual scroll indicators */
                .json-state-container {
                    background: #282c34;
                    padding: 1rem;
                    border-radius: 4px;
                    overflow: auto;
                    max-height: 400px;
                    font-size: 0.85rem;
                    position: relative;
                }
                
                .diff-container-pre {
                    background: #f5f5f5;
                    padding: 1rem;
                    border-radius: 4px;
                    overflow: auto;
                    max-height: 300px;
                    font-size: 0.85rem;
                    border: 1px solid #ddd;
                }
                
                /* Gradient fade overlay at bottom to indicate scrollable content */
                .fade-overlay {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 80px;
                    background: linear-gradient(to bottom, transparent 0%, rgba(40, 44, 52, 0.9) 70%, rgba(40, 44, 52, 1) 100%);
                    pointer-events: none;
                    border-radius: 0 0 4px 4px;
                }
                
                .fade-overlay-diff {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 60px;
                    background: linear-gradient(to bottom, transparent 0%, rgba(245, 245, 245, 0.9) 70%, rgba(245, 245, 245, 1) 100%);
                    pointer-events: none;
                    border-radius: 0 0 4px 4px;
                }
                
                /* Scroll indicator text */
                .scroll-indicator,
                .scroll-indicator-diff {
                    position: absolute;
                    bottom: 8px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 0.8rem;
                    font-weight: 500;
                    z-index: 10;
                    pointer-events: none;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    animation: bounce 2s infinite;
                }
                
                .scroll-indicator {
                    color: #9ca3af;
                }
                
                .scroll-indicator-diff {
                    color: #666;
                }
                
                @keyframes bounce {
                    0%, 100% { transform: translateX(-50%) translateY(0); }
                    50% { transform: translateX(-50%) translateY(-5px); }
                }
            </style>

            <script>
                const initialState = {
                    "player": {
                        "position": { "x": 32, "y": 29 },
                        "health": 9,
                        "facing": { "x": 0, "y": -1 },
                        "action": "move_up",
                        "inventory": {
                            "wood": 0,
                            "stone": 0,
                            "coal": 0
                        }
                    },
                    "entities": [
                        {
                            "type": "tree",
                            "position": { "x": 32, "y": 28 }
                        },
                        {
                            "type": "cow",
                            "entity_id": 15,
                            "position": { "x": 21, "y": 27 },
                            "health": 3
                        },
                        {
                            "type": "zombie",
                            "entity_id": 67,
                            "position": { "x": 41, "y": 10 },
                            "health": 5,
                            "cooldown": 0
                        }
                    ],
                    "step_count": 4
                };

                const stateAfterDo = {
                    "player": {
                        "position": { "x": 32, "y": 29 },
                        "health": 9,
                        "facing": { "x": 0, "y": -1 },
                        "action": "do",
                        "inventory": {
                            "wood": 1,
                            "stone": 0,
                            "coal": 0
                        }
                    },
                    "entities": [
                        {
                            "type": "cow",
                            "entity_id": 15,
                            "position": { "x": 22, "y": 27 },
                            "health": 3
                        },
                        {
                            "type": "zombie",
                            "entity_id": 67,
                            "position": { "x": 42, "y": 10 },
                            "health": 5,
                            "cooldown": 0
                        }
                    ],
                    "step_count": 5
                };

                const stateAfterMove = {
                    "player": {
                        "position": { "x": 33, "y": 12 },
                        "health": 8,
                        "facing": { "x": 1, "y": 0 },
                        "action": "move_right",
                        "inventory": {
                            "wood": 1,
                            "stone": 9,
                            "coal": 0
                        }
                    },
                    "entities": [
                        {
                            "type": "cow",
                            "entity_id": 20,
                            "position": { "x": 29, "y": 11 },
                            "health": 3
                        },
                        {
                            "type": "zombie",
                            "entity_id": 67,
                            "position": { "x": 42, "y": 10 },
                            "health": 5,
                            "cooldown": 0
                        },
                        {
                            "type": "zombie",
                            "entity_id": 86,
                            "position": { "x": 23, "y": 32 },
                            "health": 5,
                            "cooldown": 0
                        }
                    ],
                    "step_count": 170
                };

                let currentState = JSON.parse(JSON.stringify(initialState));

                function displayState(state) {
                    const stateElement = document.getElementById('current-state');
                    // Remove previous highlighting
                    stateElement.removeAttribute('data-highlighted');
                    stateElement.className = 'language-json';
                    // Set the JSON content
                    stateElement.textContent = JSON.stringify(state, null, 2);
                    // Apply syntax highlighting
                    hljs.highlightElement(stateElement);
                    // Check if scroll indicator should be shown
                    updateScrollIndicators();
                }
                
                function updateScrollIndicators() {
                    // Check JSON state container
                    const stateContainer = document.querySelector('.json-state-container');
                    const stateIndicator = document.querySelector('.scroll-indicator');
                    const stateFade = document.querySelector('.fade-overlay');
                    
                    if (stateContainer && stateIndicator && stateFade) {
                        const isScrollable = stateContainer.scrollHeight > stateContainer.clientHeight;
                        stateIndicator.style.display = isScrollable ? 'flex' : 'none';
                        stateFade.style.display = isScrollable ? 'block' : 'none';
                    }
                    
                    // Check diff container
                    const diffContainer = document.getElementById('state-diff');
                    const diffIndicator = document.querySelector('.scroll-indicator-diff');
                    const diffFade = document.querySelector('.fade-overlay-diff');
                    
                    if (diffContainer && diffIndicator && diffFade) {
                        const isScrollable = diffContainer.scrollHeight > diffContainer.clientHeight;
                        diffIndicator.style.display = isScrollable ? 'flex' : 'none';
                        diffFade.style.display = isScrollable ? 'block' : 'none';
                    }
                }

                function generateDiff(oldState, newState) {
                    const lines = [];
                    
                    // Player changes
                    if (oldState.player.action !== newState.player.action) {
                        lines.push(`<span class="diff-remove">- player.action: "${oldState.player.action}"</span>`);
                        lines.push(`<span class="diff-add">+ player.action: "${newState.player.action}"</span>`);
                    }
                    
                    if (oldState.player.position.x !== newState.player.position.x || 
                        oldState.player.position.y !== newState.player.position.y) {
                        lines.push(`<span class="diff-remove">- player.position: (${oldState.player.position.x}, ${oldState.player.position.y})</span>`);
                        lines.push(`<span class="diff-add">+ player.position: (${newState.player.position.x}, ${newState.player.position.y})</span>`);
                    }

                    if (oldState.player.health !== newState.player.health) {
                        lines.push(`<span class="diff-remove">- player.health: ${oldState.player.health}</span>`);
                        lines.push(`<span class="diff-add">+ player.health: ${newState.player.health}</span>`);
                    }

                    if (oldState.player.facing.x !== newState.player.facing.x || 
                        oldState.player.facing.y !== newState.player.facing.y) {
                        lines.push(`<span class="diff-remove">- player.facing: (${oldState.player.facing.x}, ${oldState.player.facing.y})</span>`);
                        lines.push(`<span class="diff-add">+ player.facing: (${newState.player.facing.x}, ${newState.player.facing.y})</span>`);
                    }
                    
                    // Inventory changes
                    for (const key in oldState.player.inventory) {
                        if (oldState.player.inventory[key] !== newState.player.inventory[key]) {
                            lines.push(`<span class="diff-remove">- player.inventory.${key}: ${oldState.player.inventory[key]}</span>`);
                            lines.push(`<span class="diff-add">+ player.inventory.${key}: ${newState.player.inventory[key]}</span>`);
                        }
                    }
                    
                    // Entity changes
                    const oldEntities = new Map(oldState.entities.map(e => [e.entity_id, e]));
                    const newEntities = new Map(newState.entities.map(e => [e.entity_id, e]));
                    
                    for (const [id, oldEntity] of oldEntities.entries()) {
                        const newEntity = newEntities.get(id);
                        if (!newEntity) {
                            lines.push(`<span class="diff-remove">- Entity removed: ${oldEntity.type} (id: ${id})</span>`);
                        } else if (oldEntity.position.x !== newEntity.position.x || 
                                   oldEntity.position.y !== newEntity.position.y) {
                            lines.push(`<span class="diff-remove">- ${oldEntity.type}(${id}).position: (${oldEntity.position.x}, ${oldEntity.position.y})</span>`);
                            lines.push(`<span class="diff-add">+ ${newEntity.type}(${id}).position: (${newEntity.position.x}, ${newEntity.position.y})</span>`);
                        }
                    }
                    
                    for (const [id, newEntity] of newEntities.entries()) {
                        if (!oldEntities.has(id)) {
                            lines.push(`<span class="diff-add">+ Entity added: ${newEntity.type} (id: ${id}) at (${newEntity.position.x}, ${newEntity.position.y})</span>`);
                        }
                    }
                    
                    // Step count
                    if (oldState.step_count !== newState.step_count) {
                        lines.push(`<span class="diff-remove">- step_count: ${oldState.step_count}</span>`);
                        lines.push(`<span class="diff-add">+ step_count: ${newState.step_count}</span>`);
                    }
                    
                    return lines.join('\n');
                }

                function applyAction(actionType) {
                    const oldState = JSON.parse(JSON.stringify(currentState));
                    
                    if (actionType === 1) {
                        currentState = JSON.parse(JSON.stringify(stateAfterDo));
                    } else if (actionType === 2) {
                        currentState = JSON.parse(JSON.stringify(stateAfterMove));
                    }
                    
                    displayState(currentState);
                    
                    const diffHtml = generateDiff(oldState, currentState);
                    document.getElementById('state-diff').innerHTML = diffHtml;
                    document.getElementById('diff-container').style.display = 'block';
                    
                    // Update scroll indicators after DOM updates
                    setTimeout(updateScrollIndicators, 50);
                }

                function resetState() {
                    currentState = JSON.parse(JSON.stringify(initialState));
                    displayState(currentState);
                    document.getElementById('diff-container').style.display = 'none';
                }

                // Initialize display - wait for both DOM and highlight.js to be ready
                function initializeDisplay() {
                    if (typeof hljs !== 'undefined') {
                        displayState(currentState);
                        // Check scroll indicators after a brief delay to ensure rendering is complete
                        setTimeout(updateScrollIndicators, 100);
                    } else {
                        // Retry after a short delay if hljs isn't loaded yet
                        setTimeout(initializeDisplay, 100);
                    }
                }
                
                // Initialize when DOM is ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initializeDisplay);
                } else {
                    initializeDisplay();
                }
            </script>

            <p style="margin-top: 1.5rem;">
                The state representation captures the complete game world including player attributes (position, health, inventory), entities (cows, zombies, trees), and environmental properties. When an action is taken, multiple aspects of the state can change simultaneously: the player's action and inventory update, entities may move (like the cow and zombie), and environmental objects (like trees) may be removed. The world model must learn to predict these cascading changes from observing transitions.
            </p>
        </div>
    </div>
</section>

<section class="section" id="sec-evaluation">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Evaluation Protocols and Metrics</h2>
        <div class="content has-text-justified">
            <figure style="margin-bottom: 2rem;">
                <img src="static/evaluation_sketch.png" alt="Evaluation metrics illustration" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Two evaluation metric categories. We assess world models through <strong>state ranking</strong> (ability to distinguish plausible future states from implausible ones using programmatic mutators) and <strong>state fidelity</strong> (ability to generate states that closely resemble reality using edit distance metrics).
                </figcaption>
            </figure>
            
            <p>
                Evaluating world models for stochastic environments requires measuring two key capabilities:
            </p>
            
            <h3 class="title is-5">State Ranking</h3>
            <p>
                These metrics assess whether the model ranks the true next state higher than distractor states. We create distractors using <strong>mutators</strong>‚Äîprogrammatic functions that apply semantically meaningful, rule-breaking changes (e.g., allowing crafting without prerequisites).
            </p>
            <ul>
                <li><strong>Rank @ 1 (R@1):</strong> Binary metric measuring if the model assigns highest probability to the true state.</li>
                <li><strong>Mean Reciprocal Rank (MRR):</strong> Averages the reciprocal rank of the correct state: \(\text{MRR} = \frac{1}{N} \sum_{i=1}^{N} \frac{1}{r_i}\)</li>
            </ul>
            
            <h3 class="title is-5">State Fidelity</h3>
            <p>
                These metrics measure the error between predicted and ground truth states:
            </p>
            <ul>
                <li><strong>Raw Edit Distance:</strong> Number of atomic JSON Patch operations needed to transform predicted state into ground truth.</li>
                <li><strong>Normalized Edit Distance:</strong> Raw edit distance divided by total state elements.</li>
            </ul>
        </div>
    </div>
</section>

<section class="section">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Evaluation Framework Implementation on Crafter-OO</h2>
        <div class="content has-text-justified">
            <p>
                Evaluating a world model on random rollouts may not provide sufficient coverage of rare or important events in an environment. To ensure our evaluation is comprehensive, we create evaluation trajectories from a suite of <strong>scenarios</strong>. Each scenario runs a short, scripted policy from an initial state designed to reliably exercise a specific game mechanic or achieve a particular goal.
            </p>
            
            <p>
                Our scenarios cover every achievement in the achievement tree of Crafter-OO/Crafter, ranging from basic actions like collecting wood to complex, multi-step tasks like crafting an iron sword. We generate distractors for each transition in the evaluation dataset using a bank of 8 mutators which each produce a subtle, but illegal transformation of the game state in response to an action‚Äîsuch as causing an incorrect item to be produced when taking a crafting action, or allowing an item to be produced without the correct requirements.
            </p>

            <figure style="margin: 2rem 0;">
                <img src="static/scenario_mrr_results.png" alt="Per-scenario MRR results" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Per-scenario state ranking performance of <span class="system-name">OneLife</span> (Ours) versus <span style="color: red;">PoE-World</span>, measured by Mean Reciprocal Rank (MRR ‚Üë). Scenarios are grouped by the core game mechanic they test. Horizontal lines show the average MRR across all scenarios in a group for <span class="system-name">OneLife</span> and <span style="color: red;">PoE-World</span>. <span class="system-name">OneLife</span> demonstrates a more accurate understanding of the environment's laws, achieving a higher average MRR and outperforming the baseline on the majority of individual scenarios.
                </figcaption>
            </figure>

            <h3 class="title is-4">Experimental Setup and Results</h3>
            
            <p>
                We conduct a series of experiments to evaluate <span class="system-name">OneLife</span>. First, we quantitatively assess the model's predictive accuracy using our state ranking and fidelity metrics across a comprehensive suite of scenarios. Second, we test the model's ability to support planning in imagination by performing simulated rollouts of different policies.
            </p>

            <h4 class="title is-5">Baseline Models</h4>
            <ul>
                <li><strong>Random World Model:</strong> A model that assigns uniform probability to all candidate states. Its performance is equivalent to random guessing and serves as a sanity check.</li>
                <li><strong>PoE-World:</strong> A state-of-the-art symbolic world model that scaled symbolic world modeling to domains like Atari. Both PoE-World and <span class="system-name">OneLife</span> represent the transition function as a weighted product of programs. We reimplement this baseline with our exploration policy and law synthesizer.</li>
            </ul>

            <h4 class="title is-5">Results</h4>
            
            <figure style="margin: 2rem 0;">
                <img src="static/table_wm_comparison.png" alt="World model comparison table" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Performance comparison of world modeling methods on the Crafter-OO environment, averaged over ten trials. We evaluate models on two criteria: <strong>state fidelity</strong> and <strong>state ranking</strong>. All methods use the <span class="system-name">OneLife</span> exploration policy and law synthesizer but differ in their parameter inference method. <span class="system-name">OneLife</span> shows significant improvements over the PoE-World inference algorithm and <span class="system-name">OneLife</span> variant without parameter inference. The random baseline is shaded in gray.
                </figcaption>
            </figure>
        </div>
    </div>
</section>

<section class="section">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Planning with the Learned World Model</h2>
        <div class="content has-text-justified">
            <p>
                To assess the practical utility of the learned world model, we evaluate its effectiveness in a planning context. Our protocol tests the model's ability to distinguish between effective and ineffective plans through forward simulation. For a set of scenarios, we define a reward function and two distinct, programmatic policies (plans) to achieve a goal within the scenario. Each plan is represented as a hierarchical policy (in code) that composes subroutines for navigation, interaction, and crafting.
            </p>
            
            <p>
                We execute rollouts of both plans within our learned world model and, separately, within the ground-truth environment. The measure of success is whether the world model's simulation yields the same preference ranking over the two plans as the true environment, based on the final reward. This assesses if the model has captured the causal dynamics necessary for goal-directed reasoning.
            </p>
            
            <h3 class="title is-5">Setup</h3>
            <p>
                We design three scenarios that test distinct aspects of the environment's mechanics: combat, tool-use and resource consumption. In the <strong>Zombie Fighter</strong> scenario, an agent with low health must defeat two zombies. The superior plan involves a multi-step process: pathfinding to locate and harvest trees, crafting a table and then a sword, and only then engaging in combat. The alternative is to fight immediately.
            </p>
            
            <p>
                The <strong>Stone Miner</strong> scenario tests the model's understanding of resource collection. The effective plan is to first harvest wood, craft a pickaxe, pathfind to a stone, and then mine. Attempting to mine stone directly is ineffective. Finally, the <strong>Sword Maker</strong> scenario evaluates knowledge of resource consumption. The goal is to craft multiple swords. The efficient plan places a single crafting table and reuses it, whereas the inefficient plan wastes wood by placing a new table for each sword.
            </p>
            
            <p>
                On average, a plan requires approximately 18 steps to execute, with the longest plans taking over 30 steps. Thus, simulating the results of these plans tests the ability of the world model to accurately model the consequences of long sequences of actions upon the world.
            </p>
            
            <figure style="margin: 2rem 0;">
                <img src="static/plan_qualitative_animated.gif" alt="Plan execution within OneLife's world model" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Example of plan execution <em>within</em> <span class="system-name">OneLife</span>'s world model for the "Stone Miner" scenario. The effective plan carries out a multi-step sequence of gathering wood, crafting a wooden pickaxe, and then attempting to mine. The ineffective plan attempts to mine the stone directly. The world learned by <span class="system-name">OneLife</span> correctly simulates causal game mechanics that cause the effective plan to succeed and the ineffective plan to fail.
                </figcaption>
            </figure>
            
            <h3 class="title is-5">Results</h3>
            <p>
                Across all three scenarios, our learned world model correctly predicts the more effective plan. The ranking of plans generated by simulating rollouts in <span class="system-name">OneLife</span> matches the ranking from the ground-truth environment. For instance, in the Zombie Fighter scenario, the model correctly simulates that the multi-step plan of crafting a sword leads to higher Damage Per Second, identifying it as the superior strategy. This demonstrates that <span class="system-name">OneLife</span> captures a sufficiently accurate causal model of the world to support basic, goal-oriented planning.
            </p>
            
            <figure style="margin: 2rem 0;">
                <img src="static/table_planning_results.png" alt="Planning results table" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;">
                <figcaption class="caption">
                    Planning results across three scenarios. <span class="system-name">OneLife</span> correctly identifies the superior plan in each scenario by simulating rollouts and comparing final rewards.
                </figcaption>
            </figure>
        </div>
    </div>
</section>

<section class="section" id="sec-laws">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Synthesized World Laws</h2>
        <div class="content has-text-justified">
            <p>
                <span class="system-name">OneLife</span> synthesizes modular, programmatic laws that capture the dynamics of the environment. Each law implements a precondition-effect structure where the precondition determines when the law should activate, and the effect specifies how the world state changes. Below are examples of laws synthesized by our system:
            </p>
        </div>

        <div class="law-carousel-container">
            <div class="law-carousel">
                <!-- Slide 1: Zombie Chase Law -->
                <div class="law-slide active" data-law="zombie-chase">
                    <h3 class="law-title">Zombie Chase Law</h3>
                    <div class="law-code-container">
                        <pre><code class="language-python">class ZombieAggroMovement:
    def __init__(self):
        """Initialize with configurable parameters."""
        pass # No specific parameters are needed for this observed law.
    
    def precondition(self, current_state: WorldState, action: str) -> bool:
        """Return True if this law should apply to the given state and action."""
        # This law applies if there are any ZombieState entities within the player's
        # update range, as their movement is an autonomous process.
        zombies_in_range = current_state.get_object_of_type_in_update_range(ZombieState)
        return len(zombies_in_range) > 0
    
    def effect(self, current_state: WorldState, action: str) -> None:
        """Apply the law by modifying the world state."""
        player_pos = current_state.player.position

        # Retrieve all ZombieState objects that are within the update range.
        # This implicitly filters for zombies close enough to be active/observable.
        zombies_to_update = current_state.get_object_of_type_in_update_range(ZombieState)

        for zombie in zombies_to_update:
            # Calculate the differences in coordinates between the player and the zombie.
            dx = player_pos.x - zombie.position.x
            dy = player_pos.y - zombie.position.y

            # Initialize new positions to current positions (no movement by default)
            new_x = zombie.position.x
            new_y = zombie.position.y

            # Prioritize movement along the X-axis
            if dx != 0:
                # Move one step towards the player along the X-axis.
                new_x = zombie.position.x + (1 if dx > 0 else -1)
            elif dy != 0:
                # If X-axis is already aligned, move one step towards the player along the Y-axis.
                new_y = zombie.position.y + (1 if dy > 0 else -1)
            
            # Update the zombie's position in the state using DiscreteDistribution.
            zombie.position.x = DiscreteDistribution(support=[new_x])
            zombie.position.y = DiscreteDistribution(support=[new_y])</code></pre>
                    </div>
                </div>

                <!-- Slide 2: Skeleton Movement Law -->
                <div class="law-slide" data-law="skeleton-movement">
                    <h3 class="law-title">Skeleton Random Movement Law</h3>
                    <div class="law-code-container">
                        <pre><code class="language-python">class SkeletonRandomMovementLaw:
    def __init__(self):
        """Initialize with configurable parameters."""
        pass
    
    def precondition(self, current_state: WorldState, action: str) -> bool:
        """Return True if this law should apply to the given state and action."""
        # This law applies generally to all skeletons, independent of player action for movement
        return True
    
    def effect(self, current_state: WorldState, action: str) -> None:
        """Apply the law by modifying the world state."""
        skeletons = [obj for obj in current_state.objects if isinstance(obj, SkeletonState)]

        for skeleton in skeletons:
            current_x = skeleton.position.x
            current_y = skeleton.position.y

            # Possible next X positions: current_x, current_x + 1, current_x - 1
            skeleton.position.x = DiscreteDistribution(support=[
                current_x, 
                current_x + 1, 
                current_x - 1
            ])
            # Possible next Y positions: current_y, current_y + 1, current_y - 1
            skeleton.position.y = DiscreteDistribution(support=[
                current_y, 
                current_y + 1, 
                current_y - 1
            ])</code></pre>
                    </div>
                </div>

                <!-- Slide 3: Craft Stone Pickaxe Law -->
                <div class="law-slide" data-law="craft-pickaxe">
                    <h3 class="law-title">Craft Stone Pickaxe Law</h3>
                    <div class="law-code-container">
                        <pre><code class="language-python">class CraftStonePickaxe:
    def __init__(self):
        """Initialize with configurable parameters."""
        # No specific parameters needed for this crafting recipe.
        pass
    
    def precondition(self, current_state: WorldState, action: str) -> bool:
        """Return True if this law should apply to the given state and action."""
        # Check if the action is "Make Stone Pickaxe"
        if action == "Make Stone Pickaxe":
            # Check if player has required materials
            has_wood = current_state.player.inventory.wood >= 1
            has_stone = current_state.player.inventory.stone >= 1
            return has_wood and has_stone
        return False
    
    def effect(self, current_state: WorldState, action: str) -> None:
        """Apply the law by modifying the world state."""
        # Decrease wood by 1
        current_state.player.inventory.wood = DiscreteDistribution(support=[current_state.player.inventory.wood - 1])
        # Decrease stone by 1
        current_state.player.inventory.stone = DiscreteDistribution(support=[current_state.player.inventory.stone - 1])
        # Increase stone_pickaxe by 1
        current_state.player.inventory.stone_pickaxe = DiscreteDistribution(support=[current_state.player.inventory.stone_pickaxe + 1])</code></pre>
                    </div>
                </div>

                <!-- Slide 4: Mine Stone Law -->
                <div class="law-slide" data-law="mine-stone">
                    <h3 class="law-title">Mine Stone Law</h3>
                    <div class="law-code-container">
                        <pre><code class="language-python">class MineStoneLaw:
    def __init__(self):
        """Initialize with configurable parameters."""
        pass
    
    def precondition(self, current_state: WorldState, action: str) -> bool:
        """Return True if this law should apply to the given state and action."""
        if action != "Do":
            return False
        
        target_material, _ = current_state.get_target_tile()
        
        if target_material == "stone":
            # Check if the player has any pickaxe
            has_pickaxe = (
                current_state.player.inventory.wood_pickaxe > 0 or
                current_state.player.inventory.stone_pickaxe > 0 or
                current_state.player.inventory.iron_pickaxe > 0
            )
            return has_pickaxe
            
        return False
    
    def effect(self, current_state: WorldState, action: str) -> None:
        """Apply the law by modifying the world state."""
        # Increment stone in inventory
        current_state.player.inventory.stone = DiscreteDistribution(
            support=[current_state.player.inventory.stone + 1]
        )
        
        # Replace the mined stone material with grass
        current_state.set_facing_material("grass")</code></pre>
                    </div>
                </div>

                <!-- Slide 5: Health Regeneration Law -->
                <div class="law-slide" data-law="health-regen">
                    <h3 class="law-title">Health Regeneration Law</h3>
                    <div class="law-code-container">
                        <pre><code class="language-python">class PlayerInventoryHealthRegeneration:
    def __init__(self, max_health: int = 20, recover_threshold: float = 1.0):
        """Initialize with configurable parameters for health regeneration."""
        self.max_health = max_health
        self.recover_threshold = recover_threshold
    
    def precondition(self, current_state: WorldState, action: str) -> bool:
        """
        Return True if the player's inventory health should regenerate.
        This law applies if the player is not at max health, has sufficient
        recover points, and is not sleeping.
        """
        player = current_state.player
        
        # Check if player's current inventory health is less than the defined maximum
        has_space_for_health = player.inventory.health < self.max_health
        
        # Check if player has sufficient recover points to enable regeneration
        has_recover_points = player.recover >= self.recover_threshold
        
        # Check if the player is not currently sleeping
        not_sleeping = not player.sleeping

        # This is a passive regeneration effect, so the specific action taken (e.g., "Move North")
        # is not a direct precondition, but the effect occurs during the state transition.
        return has_space_for_health and has_recover_points and not_sleeping
    
    def effect(self, current_state: WorldState, action: str) -> None:
        """
        Apply the law by increasing the player's inventory health by 1.
        """
        # Increment the player's inventory health by 1.
        current_state.player.inventory.health = DiscreteDistribution(support=[current_state.player.inventory.health + 1])</code></pre>
                    </div>
                </div>
            </div>

            <div class="carousel-nav">
                <button class="carousel-button" id="prev-law">
                    <i class="fas fa-chevron-left"></i>
                    <span>Previous</span>
                </button>
                
                <div class="carousel-indicators">
                    <span class="carousel-counter">
                        <span id="current-slide">1</span> / <span id="total-slides">5</span>
                    </span>
                </div>
                
                <button class="carousel-button" id="next-law">
                    <span>Next</span>
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>

        <div class="content has-text-justified" style="margin-top: 2rem;">
            <p class="caption">
                These laws are automatically synthesized from a single unguided episode in the Crafter-OO environment. Each law captures a specific aspect of the world's dynamics: zombie behavior, skeleton movement, crafting mechanics, resource gathering, and passive effects. The precondition-effect structure allows laws to activate only when relevant, creating a sparse, modular representation of the world's dynamics.
            </p>
        </div>
    </div>
</section>

<section class="section">
    <div class="container is-max-desktop content-block">
        <h2 class="title is-3">Citation</h2>
        <div class="content">
            <pre><code>@inproceedings{khan2025onelife,
  title={One Life to Learn: Inferring Symbolic World Models for Stochastic Environments from Unguided Exploration},
  author={Khan, Zaid and Prasad, Archiki and Stengel-Eskin, Elias and Cho, Jaemin and Bansal, Mohit},
  journal={arXiv preprint arXiv:2510.12088},
  year={2025}
}</code></pre>
        </div>
    </div>
</section>

<footer class="footer">
    <div class="container">
        <div class="content has-text-centered">
            <p>
                Website template adapted from <a href="https://github.com/nerfies/nerfies.github.io">Nerfies</a>
            </p>
        </div>
    </div>
</footer>

<script>
document.getElementById('copy-citation').addEventListener('click', function() {
    const citationText = `@inproceedings{khan2025onelife,
  title={One Life to Learn: Inferring Symbolic World Models for Stochastic Environments from Unguided Exploration},
  author={Khan, Zaid and Prasad, Archiki and Stengel-Eskin, Elias and Cho, Jaemin and Bansal, Mohit},
  journal={arXiv preprint arXiv:2510.12088},
  year={2025}
}`;
    
    navigator.clipboard.writeText(citationText).then(function() {
        alert('Citation copied to clipboard!');
    }, function(err) {
        console.error('Could not copy text: ', err);
    });
});
</script>

<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.24/css/jquery.dataTables.css">
<script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.24/js/jquery.dataTables.js"></script>

<script>
// Law Carousel Functionality
document.addEventListener('DOMContentLoaded', function() {
    const slides = document.querySelectorAll('.law-slide');
    const prevButton = document.getElementById('prev-law');
    const nextButton = document.getElementById('next-law');
    const currentSlideSpan = document.getElementById('current-slide');
    const totalSlidesSpan = document.getElementById('total-slides');
    
    let currentIndex = 0;
    const totalSlides = slides.length;
    
    // Initialize highlight.js for code blocks
    if (typeof hljs !== 'undefined') {
        slides.forEach(slide => {
            const codeBlock = slide.querySelector('code');
            if (codeBlock) {
                hljs.highlightElement(codeBlock);
            }
        });
    }
    
    function updateCarousel() {
        // Hide all slides
        slides.forEach((slide, index) => {
            slide.classList.remove('active');
            if (index === currentIndex) {
                slide.classList.add('active');
            }
        });
        
        // Update counter
        currentSlideSpan.textContent = currentIndex + 1;
        
        // Update button states
        prevButton.disabled = currentIndex === 0;
        nextButton.disabled = currentIndex === totalSlides - 1;
    }
    
    function nextSlide() {
        if (currentIndex < totalSlides - 1) {
            currentIndex++;
            updateCarousel();
        }
    }
    
    function prevSlide() {
        if (currentIndex > 0) {
            currentIndex--;
            updateCarousel();
        }
    }
    
    // Event listeners
    prevButton.addEventListener('click', prevSlide);
    nextButton.addEventListener('click', nextSlide);
    
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
        // Only handle arrow keys if the carousel is in view
        const carouselSection = document.getElementById('sec-laws');
        const rect = carouselSection.getBoundingClientRect();
        const isInView = rect.top < window.innerHeight && rect.bottom >= 0;
        
        if (isInView) {
            if (e.key === 'ArrowLeft') {
                prevSlide();
            } else if (e.key === 'ArrowRight') {
                nextSlide();
            }
        }
    });
    
    // Initialize total slides display
    totalSlidesSpan.textContent = totalSlides;
    
    // Initial update
    updateCarousel();
});
</script>

</body>
</html>